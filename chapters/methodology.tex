\chapter{Methodology}\label{chapter:methodology}%Todo change into chapter
In this chapter, the simulator used to investigate the research questions is described. An overview of the system is presented in section \ref{section:systemt architecture}. Section \ref{section:genetic algorithm} includes implementation details, and design decisions made when implementing the genetic algorithm which is the foundation for all the population distributed genetic algorithms. Sections \ref{section:population distributed gas} contain implementation details of the population distributed genetic algorithms. The wind scenarios used to evaluate the different population distributed genetic algorithm are described in section \ref{section:scenarios}, and the choice of implementing the genetic algorithm from scratch is defended in section \ref{section:motivation}.


\section{System Architecture}\label{section:systemt architecture}
The program is implemented in Java and the interactions between the different classes of the program are shown in figure \ref{figure:class diagram}. The GeneticAlgorithm class is extended by the three population distributed genetic algorithm classes: IslandModel, CellularModel and PoolModel. In addition, the GeneticAlgorithm class is also implemented as instances in all three population distributed algorithms. The main loop of the program is contained in the GeneticAlgorithm class. It uses instances of the classes WindScenario, WindFarmLayoutEvaluator, Population, AdultSelection, ParentSelection, Crossover and Mutation. AdultSelection, ParentSeleciton and Crossover are interfaces that needs to be implemented if new methods are to be added to the program. Mutation is a class containing four different mutation methods. 


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.35]{images/"Class Diagram"}
\caption{Class Diagram.}
\label{figure:class diagram}
\end{center}
\end{figure}


\section{Genetic Algorithm}\label{section:genetic algorithm}
As mentioned in chapter \ref{chapter:background}, the genetic algorithm is a four step process: Adult selection, parent selection, recombination such as crossover and mutation, and fitness evaluation as shown in figure \ref{figure:genetic algorithm steps}. Implementation details of each step is described in the subsequent sub sections. In addition, the wind-, wake-, and power model used in evaluating the genetic algorithm are described in the following subsections since these are crucial to understanding the fitness function. 


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.3]{images/"genetic algorithm"}
\caption{Genetic algorithm.}
\label{figure:genetic algorithm steps}
\end{center}
\end{figure}


\subsection{Representation}
As in most of the studies presented in chapter \ref{chapter:relatedwork}, the individuals implemented for the genetic algorithm for this thesis are represented by binary strings. However, each position in the binary string can be directly mapped to a position in the terrain kept in an array called ''grid''. The purpose behind this design decision is that not all positions in the terrain, when dividing the terrain into a squared grid, are legal turbine positions because of the existence of obstacles. By implementing individuals this way, the genetic operations can be performed on individuals without having to check for illegal positions since this is already taken care of as soon as the scenario is read from file. Also, this design decision makes sure that no space is wasted keeping illegal positions in the binary representation. Figure \ref{figure:representation} shows how a given terrain is represented using a binary string and the grid-array. The grid to the left in the figure represents the terrain. Red cells represent illegal positions while grey cells represents legal positions. An individual and the grid array are presented to the right. Since there are only 9 legal positions in the terrain the individual has length 9. The grid-array contains the (x,y)-positions of each legal positions in the terrain. The given individual has the value 1 in positions 2, 4 and 8 respectively (zero indexed), meaning that wind turbines are positioned in the (x,y)-positions in positions 2, 4 and 8 in the grid-array, meaning position (1,2), (2,0) and (3,2) in the terrain. Wind parameters and obstacle positions are read into the program from the scenarios provided by GECCO 2016, these will be described later in this chapter.


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{images/"representation program"}
\caption{Individual representation. The grey squares represent legal turbine positions in the terrain, while the red represent illegal positions. Since there are only nine legal positions in this example, an individual is represented as a binary string of length 9. The grid array is shared between all the individuals and holds the (x, y)-coordinates for each legal position.}
\label{figure:representation}
\end{center}
\end{figure}


\subsection{Adult Selection}\label{subsection:adult selection}
Adult selection is the process of selecting which individuals that are allowed to step into the adult pool and thereby become potential parents for the next generation of individuals. Three adult selection mechanisms were implemented in this thesis: Full generational replacement,  generational mixing, and overproduction. Each method was tested in order to decide which adult selection method was more suitable for solving the wind farm layout optimization problem. \\

\noindent Full generational replacement, the simplest adult selection mechanism, replaces the previous adult population with the newly generated child population. The second method, generational mixing, is illustrated in figure \ref{figure:generational mixing}. As the name suggests, generational mixing mix the previous adult pool together with the new child pool and selects the best individuals from the mix to become the new adult population. As can be seen in the figure, the new adult pool consists of the best individuals from both the newly generated child pool and the previous adult pool. The two individuals with fitness 2 and 3 are selected from the child pool, and the two individuals with fitness 4 and 4 is selected from the previous adult pool. The new child population will therefore contain individuals with fitness 4, 2, 3 and 4, instead of fitness of 5, 6, 3 and 2, which would be the adult population if full generational replacement was used. 


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.2]{images/"adult selection"/"generational mixing"}
\caption{Generational mixing. The best individuals, from the pool consisting of individuals from the previous adult population and the new child population are selected as new the adult population.}
\label{figure:generational mixing}
\end{center}
\end{figure}


\noindent Overproduction, the third adult selection mechanism, is illustrated in figure \ref{figure:overproduction}. The newly generated child population consist of twice as many individuals as there are room for in the adult population. Therefore, the children have to compete against each other for the spots in the adult pool. \\


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.2]{images/"adult selection"/overproduction}
\caption{Overproduction. The newly generated child population consist of twice as many individuals as there are room for in the adult population. Therefore, only the fittest individuals from the large child population grow up into adults.}
\label{figure:overproduction}
\end{center}
\end{figure}



\subsection{Parent Selection}\label{subsection:parent selection}
Parent selection is the process of deciding which adults become parents for the next child generation. When choosing parent selection method there are a few concerns that needs to be addressed. First, it is important that parents with good genes, i.e. lower fitness, gets their genes transferred to the next generation. However, it is also important to keep diversity in the population so that one does not end up with a sub-optimal solution; a local maximum. Two parent selection methods are implemented for the genetic algorithm for this thesis: Tournament selection and roulette wheel selection. \\

\noindent In tournament selection, a given number of individuals are drawn randomly from the population. The number of individuals drawn is decided by the variable \textit{tournament size}. These individuals compete in a tournament for one spot in the parent pool. The individual with best, i.e. lowest fitness, is  selected as a parent. These tournaments continue until the adult pool is full. Figure \ref{figure:tournament selection} shows how tournament selection works. As can be seen in the figure, three individuals are drawn randomly from the adult pool, meaning that the tournament size in this example is 3. The best individual, the individual with fitness 4 is the tournament winner and is allowed to enter the adult pool. In order to maintain diversity in the population there is a small probability that parents are selected randomly from the adult pool instead of with tournament selection. This probability is called \textit{epsilon} and makes sure that a small percent of the parents that might not currently be best are not killed of right away. Different values of the \textit{tournament size} variable needs to be tested in order to find the settings that allow the algorithm to explore different solutions, but that also prioritize the best solutions. In chapter \ref{chapter:results}, results obtained for different values of \textit{tournament size} and \textit{epsilon} are compared. \\


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.2]{images/"parent selection"/"tournament selection"}
\caption{Tournament selection. Three individuals with fitness 9, 4 and 6 respectively, are selected randomly from the adult population. The individuals with best fitness, fitness 4, is the tournament winner and is selected into the parent pool.}
\label{figure:tournament selection}
\end{center}
\end{figure}


\noindent Roulette wheel selection assigns a probability of being chosen as parent to each individual proportional to its fitness. Individuals with better fitness will therefore have a higher probability of beings selected into the parent pool. Figure \ref{figure:roulette wheel selection} shows how roulette wheel selection works. The roulette wheel on the left shows the probability for each of the four individuals being selected. Since individual$_4$ has the best fitness, it has a larger probability of being selected than the others. \\


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{images/"parent selection"/"roulette wheel selection"}
\caption{Roulette wheel selection. The roulette wheel is shown to the left, the four individuals to the right. Individual$_4$ has a four times better fitness than individual$_2$ and therefore has a four times larger probability of being selected.}
\label{figure:roulette wheel selection}
\end{center}
\end{figure}


\subsection{Genetic Operations}\label{subsection:genetic operations}
This subsection gives an overview over the genetic operations used to produce the next child generation. Three crossover methods, elitism and four mutation methods are implemented and will be presented. 


\subsubsection{Crossover and Elitism}
Crossover is the recombination method utilized by the genetic algorithm to perform sexual reproduction. A crossover operation produced two children by recombining genes of two parent individuals. The genetic algorithm implemented for this thesis has three crossover methods to chose from: Single point crossover, two point crossover and uniform crossover \citep{Magalhaes-Mendes}. These are all presented in figure \ref{figure:crossover methods}. As shown in figure \ref{figure:single point crossover}, single point crossover uses randomly generated position, called the crossover point, to perform recombination. All genes from the first parent prior to the crossover point are copied to the first child, and all genes after the crossover point are copied to the second child, and all genes from the second parent prior to the crossover point is copied to the second child, and all genes after the crossover point is copied to the first child. Two point crossover is similar to single point crossover, except that it uses to crossover points instead of one. This is shown in figure \ref{figure:two point crossover}. In uniform crossover, there is a fifty percent probability that each gene will be drawn from each parent as shown in figure \ref{figure:uniform crossover}. This crossover method mix up the parent genes more that the two others, therefore more gene patterns will be lost using this method. Even though crossover is the main recombination method it is not used for creating every child individual. Some child individuals are copies of their parents with potential small mutation in their genes. The number of individuals created using crossover is decided by the crossover rate. Crossover rates are usually kept pretty high since the goal is to evolve new and better solutions, however test runs presented in chapter \ref{chapter:results} do confirm that it is good to let a percentage of the children be produced without crossover. \\


\begin{figure}[h!]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{images/crossover/"Single point crossover"}
        \caption{}
        \label{figure:single point crossover}
    \end{subfigure}
    ~ 
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{images/crossover/"Two point crossover"}
        \caption{}
        \label{figure:two point crossover}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{images/crossover/"Uniform crossover"}
        \caption{}
        \label{figure:uniform crossover}
    \end{subfigure}
    \caption{Crossover methods: (a) Single point crossover, (b) two point crossover, and (c) uniform crossover.}
    \label{figure:crossover methods}
\end{figure}


\noindent A method used to make sure that the best individuals in the population does not get killed of by accident is called \textit{elitism}. Elitism simply takes the best individual(s) from the parent population and copies it(them) directly into the new child population without performing any genetic operations on it(them). Elitism is commonly used with genetic algorithm and will be used in this thesis. 


\subsubsection{Mutation}
Although crossover is a powerful genetic operator that makes sure that child individuals to inherit genes from the best parent individuals, it is not enough by itself. Without any way to mutate genes, one can end up with a population where every individual has the same gene value in the same position, this means that no recombination method will be able to change the value of that gene. Mutation is the operation used by the genetic algorithm to make sure that the population do not get sterile. In nature, genes can be mutated in numerous ways. In this thesis, three mutation methods are implemented to mimic the mutations methods that can happen in genes \citep{Soni}, these are called: Flip mutation, interchanging mutation, and inversion mutation. Flip mutation, shown in figure \ref{figure:flip mutation}, is the most common mutation method used in genetic algorithms. As it's name implies, flip mutation works by flipping the value of bits in the genotype. Usually, mutation rates are low since one do not want mutation to make to many changes to the good genes inherited from parent individuals, but simply introduce some diversity. Therefore, only a couple of bits are mutated in each genotype each generation. Interchange mutation and inversion mutation are rarely used in genetic algorithms, however they are included in this thesis to introduce even more diversity in the population and hopefully help the genetic search finding even better solutions. They both introduce more change than flip mutation, and will be assigned rates even lower than the mutation rate for flip mutation. Figure \ref{figure:interchange mutation} and \ref{figure:inversion mutation} shows interchange- and inversion mutation respectively. Interchange mutation works by by picking two random genes and interchange their values, while inversion mutation works by picking two random positions and invert each gene between those positions. 


\begin{figure}[h!]
    \centering
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{images/mutation/"flip mutation"}
        \caption{}
        \label{figure:flip mutation}
    \end{subfigure}
    ~ 
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{images/mutation/"interchanging mutation"}
        \caption{}
        \label{figure:interchange mutation}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.3\textwidth}
        \includegraphics[width=\textwidth]{images/mutation/"inversion mutation"}
        \caption{}
        \label{figure:inversion mutation}
    \end{subfigure}
    \caption{Mutation methods: (a) Single point crossover, (b) two point crossover, and (c) uniform crossover.}
    \label{figure:mutation methods}
\end{figure}


\subsection{Wind-, Wake- and Power Model}\label{subsection:wind-, wake- and power model}
The evaluation class uses the same wake-, wind- and power model as \cite{Kusiak}. The wake model used is the classical Jensen model \citep{Jensen}, which is used in almost every study of the wind farm layout optimization problem, as can be seen in table \ref{table:overview}. \\

\noindent Wind distribution is modeled using the Weibull distribution, a continuous probability distribution shown to model wind distribution quite well \citep{Justus}. The probability density function is shown in equation \ref{equation:Weibull}


\begin{equation}
f(x; c, k)  = 
\begin{cases}
\frac{k}{c} \left( \frac{x}{c} \right)^{k-1} e^{- \left( \frac{x}{c} \right)^k } & \text{if} \hspace{1mm} x \geq 0 \\
0                                                                                                                      & \text{if} \hspace{1mm}     x < 0
\end{cases}
\label{equation:Weibull}
\end{equation}


\noindent where $k$ is called the shape parameter and $c$ is the scale parameter, and $k, c > 0$. In most of the wind scenarios provided by GECCO 2016, $k \approx 2$, this is shown empirically to be a good value for wind speed distribution \citep{Justus}. On the other hand, the shape parameter vary for each wind direction. Figure \ref{figure:weibull distribution} shows the Weibull distribution plotted for $k = 2$ and for different values of $c$. \\


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{images/"Weibull"}
\caption{The Weibull distribution plotted for $k = 2$ for different values of the scale parameter $c$.}
\label{figure:weibull distribution}
\end{center}
\end{figure}

\noindent The wind scenarios used in this thesis are therefore a specification of the shape- and scale parameters for every wind direction, where wind direction is partitioned into 24 different directions. Twenty wind scenarios are provided by GECCO 2016, 10 which simply specify wind distribution parameters, and 10 that specify wind distribution parameters and locations of obstacles. \\

\noindent The power curve used is also the same as used in \cite{Kusiak}, it is the linear function shown in equation \ref{equation:Power Curv (API)},

\begin{equation}
 f(v) = 
  \begin{cases} 
   0                                  & \text{if }     v < v_{cut-in} \\
   \lambda v + \eta           & \text{if }     v_{cut-in} \leq v \leq v_{rated} \\
   P_{rated}                        & \text{if }     v_{cut-out} > v > v_{rated}. \\
  \end{cases}
  \label{equation:Power Curv (API)}
\end{equation}

\noindent Here $\lambda$ is the slope parameter, $v$ the wind speed, $\eta$ the intercept parameter, $P_{rated}$ is the fixed power output, and $v_{cut-in}$ is the cut-in speed; the minimum speed for which the turbine produces power, and $v_{cut-out}$ is the cut-out speed; the maximum wind speed for which the turbine is kept on. 


\subsection{Fitness Function}\label{subsection:fitness function}
The main task of the evaluation classes is to calculate the fitness of each individual based on the fitness function.  The fitness function to be optimized is provided by GECCO 2016, and is displayed in equation \ref{Objective function}.\\

\begin{small}
\begin{equation}
fitness =  \frac{ \left( c_t \cdot n + c_s \cdot \floor*{\frac{n}{m}} \right) \left( \frac{2}{3} + \frac{1}{3} \cdot e^{-0.00174n^2} \right) + c_{OM} \cdot n}{\left( \frac{1 - (1 + r)^{-y}}{r} \right) } \cdot \frac{1}{8760 \cdot P} + \frac{0.1}{n}
\label{Objective function} 
\end{equation}
\end{small}


\noindent Description and numerical values of all parameters given in equation \ref{Objective function} are displayed in table \ref{Parameters}. As can be seen in this table, the values of $n$, the number of turbines, and $P$, farm energy output, are not given. This is because the number of turbines, together with the turbine positions, are the parameters to be optimized by the genetic algorithm. Farm energy output is the indirect parameter that we are trying to optimize. It is dependent on turbines count, position, wind scenario and so on, and is off course therefore not provided in table \ref{Parameters} either.\\


\begin{table}[h!]
\begin{center}
\caption{Description and value of each parameter used in the objective function provided by GECCO 2015.}
\label{Parameters}
\begin{tabular}{l|l|l}
\textbf{Parameter} & \textbf{Description} & \textbf{Value} \\ 
\hline 
$c_t$ & Turbine cost (usd) & 750 000 \\ 
$c_s$ & Substation cost (usd) & 8 000 000 \\ 
$m$ & Turbines per substation & 30 \\ 
$r$ & Interest rate & 0.03 \\ 
$y$ & Farm lifetime (years) & 20 \\ 
$c_{OM}$ & Yearly operating costs per turbine & 20 000 \\ 
$n$ & Number of turbines &  \\ 
$m$ & Farm energy output &  \\  
\end{tabular} 
\end{center}
\end{table}


\noindent Intuitively, the objective function can be divided into different parts. The first parenthesis in the nominator of the first fraction is the construction cost, while the second parenthesis is the economies of scale and the third part of the nominator is yearly operating costs. The denominator represents the interests. The denominator of the second fraction describes yearly power output, while the number $0.1$ in the nominator of the last fraction is a farm size coefficient. \\


\section{Population Distributed Genetic Algorithms}\label{section:population distributed gas}
Since the population distributed genetic algorithms implemented are described in chapter \ref{chapter:background} they will not be described in detail here. However, each design decision will be described. As mentioned in chapter \ref{chapter:background}, for the Island model, one have to make the decision if migration is synchronous or asynchronous, meaning that all migration is performed at the same generation or at different generations respectively. For the Island model implemented in this thesis the synchronized version is implemented. As the Island model, the Cellular model will also perform updating at the same time, i.e. at the same generation. The pool model on the other hand is asynchronous by nature. Each processor performs its own assignment without even knowing about the presence of the other processors. The second design decision made is whether each model is homogeneous or heterogeneous, where homogeneous means that each deme, cell or processor uses the same parameter settings and methods. In this thesis, each model will be homogeneous. This decision is based solidly on the fact that there will be too many combinations of different settings if each deme, cell or processor used different settings that it would be impossible to do proper testing for all of them. 


Pool model implementation details: 
In the pool model, the individuals are distributed in a resource pool so that each thread is responsible for its own area in the resource pool. Since each individual has its own position in the resource pool it does not make sense to use an adult selection mechanisms that results in an adult pool with a population size larger than the size of the resource pool. Therefore, the adult selection step is skipped for this model. As mentioned in the background, parent selection is performed by drawing individuals from random positions in the entire resource pool, not just the area for which the given thread is responsible. However, in this implementation, the individuals are not draw at random, but selected by tournament selection, where the individuals competing in the tournaments are drawn from random positions in the entire resource pool. Each thread selects one parent for each position it is responsible for, genetic operations are performed to produce the child generations. After the child pool for a thread is generated, each child individual is compared against the individual in their destination position, and the old individual is replaced if the new individual has a better fitness.


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.5]{images/"pool model update function"}
\caption{Pool model updating function. For each generation, each thread updates its region if the new individuals are better than the individuals currently occupying the position.}
\label{figure:pool model update function}
\end{center}
\end{figure}


\section{Scenarios}\label{section:scenarios}
GECCO 2016 has provided the contestants with 20 different wind scenarios for which the genetic algorithm can be tested on. Each wind scenario contain shape and scale parameters, k and c respectively, for each wind directions where wind direction is partitioned into slots that cover an 15 degree angle each, so that there are 24 different wind directions. Unavailable areas are described in the scenario by the parameters \textit{x$_{min}$, x$_{max}$, y$_{min}$} and \textit{y$_{max}$} as shown in figure \ref{figure:obstacles}. In the figure, two obstacles are described giving their (x, y)-boundaries. The red lines gives the boundaries of obstacle 1 and the blue lines gives the boundaries of obstacle 2. The yellow area in the middle of the lines shows the illegal areas. Each wind scenario also contain values for the constants ''width'', ''height'', ''number of turbines'' and ''wake free energy''. The scenarios are read from file at the beginning of each run of the genetic algorithm. 


\begin{figure}[h!]
\begin{center}
\includegraphics[scale=0.4]{images/obstacles}
\caption{Obstacles are described in the scenarios with its (x, y)-boundaries.}
\label{figure:obstacles}
\end{center}
\end{figure}


\section{Motivation behind Implementing the Genetic Algorithm from Scratch}\label{section:motivation}
Even though GECCO	 2016 has provided each contestant with an API which could be used directly, or improved upon and used in the competition, the decision to implement the genetic algorithm from scratch was made. Even though this decision lead to more work for the author, several arguments supported the decision. First of all, even though the provided API was implemented in Java, it was not very object oriented nor was it modular, something that made it very difficult to add new features to the code without having to do major changes. In addition, the provided genetic algorithm was extremely simple with no room for making any decisions about which method to use for any of the steps in figure \ref{figure:genetic algorithm steps}. Other problems such as hard-coded variables and too long methods made it very difficult to make changes and add new features. \\

\noindent The new genetic algorithm is implemented so that new selection methods can be added by simply implementing the AdultSelection- or ParentSelection interface, and new crossover methods can be added by extending the Crossover class. This makes the program much more flexible, if one wish to try something new. No variables are hard-coded in the new program, but taken as parameters to the GeneticAlgorithm constructor, leaving no room for making errors. The major improvement, and most important motivation behind the decisions of implementing the genetic algorithm from scratch is that it gives the author total control over every aspect of the code, and it was very important with modular code when the population distributed genetic algorithms were implemented.